# 数据分区

MergeTree进行数据查询时，可以有效跳过无用的数据文件，只使用最小的分区目录子集。

* ClickHouse中，数据分区(partition)和数据分片(shard)是完全不同的概念。数据分区是针对本地数据而言，是对数据的一种纵向切分，MergeTree并不能依靠分区的特性，将一张表的数据分布到多个ClickHouse服务节点；
* 横向切分是数据分片(shard)的能力。

&nbsp;

## 数据分区规则

MergeTree数据分区规则由分区ID决定，具体到每个数据分区对应的ID， 由分区键的取值决定。分区键支持使用一个或者一组字段表达式声明，针对取值数据类型的不同，分区ID的生成逻辑有以下规则:

* **不指定分区键**：不设置分区键，分区ID默认取名`all`，所有数据都会被写入这个`all`分区。
* **整型**：分区键取值属于整型，且无法转换为日期类型(`YYYYMMDD`)格式，则直接按照整型的字符串形式输出，作为分区ID的取值。
* **日期**：如果分区键属于日期类型，或者能够转换为`YYYYMMDD`格式的整型，则使用 `YYYYMMDD` 进行格式化后字符串输出，并作为分区ID取值。
* **其他类型**： 如果分区键不属于整型、日期类型，例如`String`、`Float`类型等，则通过128位hash值作为分区ID的取值。

数据写入时，会按照分区ID落入相应的数据分区。如果通过元组的方式使用多个分区字段，格式如下：

```SQL
PARTITION BY (length(Code), EventTime)

# 生成如下格式
2-20190501
2-20190611
```

&nbsp;

### 分区命名规则

MergeTree分区目录的完整物理名称并不是只有ID，在ID之后还存在一串表示其他含义的数字。命名公式格式如下：

```SQL
PartitionID_MinBlockNum_MaxBlockNum_Level

# 201905: 分区目录的ID
# 1_1: 最小的数据块编号与最大的数据块编号
# _0: 目前合并的层级
# Eg: 201905_1_1_0  => PartitionID_MinBlockNum_MaxBlockNum_Level
```

* **partitionID**：分区ID
* **MinBlockNum 和MaxBlockNum**：最小数据块编号与最大数据块编号，该编号在表级别全局唯一。此处的数据块编号命名规则和分区目录合并后数据块编号格式相同，但代表的含义有所差异。默认情况下，新创建分区目录的 `MinBlockNum`和`MaxBlockNum` 相同(`201905_1_1_0`、`201905_2_2_0`)，当数据分区发生合并后，产生的目录名称会有新的含义。
* **Level**：合并的层级，表示在某个分区内被合并过的次数。Level编号是分区级别的惟一，之后以分区为单位，如果相同分区发生合并动作，在相应分区内计数器累加1。

&nbsp;

### 分区目录合并

MergeTree的分区目录并不是在数据表创建之后就存在的，而是在数据写入过程中被创建的。每一批数据的写入(一次`insert`操作)，MergeTree都会生成一批新的分区目录，即使不同批次写入的数据属于相同分区，也会生成不同的分区目录。在插入之后的某个时刻(写入后10～15分钟)，ClickHouse通过后台任务将属于相同分区的多个目录合并成一个新的目录。已经存在的旧分区目录并不会即刻被删除，而是在之后的某个时刻(默认8分钟)通过后台任务删除。

属于同一个分区的多个目录，在合并之后会生成一个全新的目录，目录中的索引和数据文件会进行合并。新的目录格式如下：

* **MinBlockNum**：取同一个分区所有目录中最小的`MinBlockNum`值。
* **MaxBlockNum**：取同一个分区所有目录中最大的`MaxBlockNum`值。
* **Level**：取同一个分区内最大`Level`值并加1。
